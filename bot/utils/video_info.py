import asyncio
import shutil
from urllib.parse import urlparse, parse_qs

import ffmpeg
import yt_dlp
import requests
from PIL import Image
import io

from aiogram.client.session import aiohttp

from bot.proxy.proxy_manager import get_available_proxy
from bot.utils.log import log_action


# üìπ –ü–æ–ª—É—á–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –∏ —Ä–∞–∑–º–µ—Ä—ã –≤–∏–¥–µ–æ
async def get_video_resolutions_and_sizes(url):
    try:
        proxy = await get_proxy()

        ydl_opts = {
            'proxy': proxy['url'] if proxy else None,
            'skip_download': True
        }
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info_dict = ydl.extract_info(url, download=False)
            formats = info_dict.get("formats", [])
            resolution_sizes = {}
            for fmt in formats:
                width = fmt.get("width")
                height = fmt.get("height")
                filesize = fmt.get("filesize")
                if width and height and filesize:
                    resolution = f"{width}x{height}"
                    filesize_mb = float(filesize) / (1024 * 1024)
                    resolution_sizes[resolution] = max(resolution_sizes.get(resolution, 0), filesize_mb)
            return resolution_sizes
    except Exception as e:
        log_action(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π –≤–∏–¥–µ–æ: {e}")
        return {}

# üñºÔ∏è –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–µ–≤—å—é
async def get_thumbnail_bytes(url):
    try:
        response = requests.get(url, stream=True)
        if response.status_code == 200:
            img = Image.open(io.BytesIO(response.content))
            img = img.convert("RGB")
            img.thumbnail((320, 320))
            byte_io = io.BytesIO()
            img.save(byte_io, format="JPEG", optimize=True, quality=85)
            byte_io.seek(0)
            return byte_io
        return None
    except Exception as e:
        log_action(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–µ–≤—å—é: {e}")
        return None

# üìÑ –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ (ID, –Ω–∞–∑–≤–∞–Ω–∏–µ, –ø—Ä–µ–≤—å—é)


async def get_video_info(url):
    log_action('‚ö° –ë—ã—Å—Ç—Ä–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ oEmbed')

    try:
        # –ü–æ–ª—É—á–∞–µ–º video_id
        parsed_url = urlparse(url)
        video_id = None

        if 'youtube.com' in parsed_url.netloc:
            query = parse_qs(parsed_url.query)
            video_id = query.get('v', [None])[0]
        elif 'youtu.be' in parsed_url.netloc:
            video_id = parsed_url.path.strip('/')

        if not video_id:
            log_action('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å ID –≤–∏–¥–µ–æ')
            return None, None, None

        # oEmbed –∑–∞–ø—Ä–æ—Å
        oembed_url = f"https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v={video_id}&format=json"

        async with aiohttp.ClientSession() as session:
            async with session.get(oembed_url) as resp:
                if resp.status != 200:
                    raise Exception(f"–û—à–∏–±–∫–∞ oEmbed: {resp.status}")
                data = await resp.json()

        title = data.get("title", "–í–∏–¥–µ–æ")
        thumbnail_url = data.get("thumbnail_url")

        return video_id, title, thumbnail_url

    except Exception as e:
        log_action(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≤–∏–¥–µ–æ: {e}")
        return None, None, None



def check_ffmpeg_installed():
    if not shutil.which("ffmpeg"):
        raise EnvironmentError("FFmpeg –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –µ–≥–æ –∏ –¥–æ–±–∞–≤—å—Ç–µ –≤ PATH.")


async def get_video_resolution(video_path):
    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º ffmpeg.probe –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –≤–∏–¥–µ–æ
        probe = ffmpeg.probe(video_path)
        video_stream = next((stream for stream in probe["streams"] if stream["codec_type"] == "video"), None)
        if video_stream:
            width = int(video_stream["width"])
            height = int(video_stream["height"])
            return width, height
        return None, None  # –ï—Å–ª–∏ –≤–∏–¥–µ–æ—Å—Ç—Ä–∏–º –Ω–µ –Ω–∞–π–¥–µ–Ω
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –≤–∏–¥–µ–æ: {e} {video_path}")
        return None, None  # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏

async def get_proxy():
    proxy = {'ip': '127.0.0.1', 'port': '9050', 'user': '', 'password': ''}  # Tor –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    proxy_url = f"socks5://{proxy['ip']}:{proxy['port']}"
    log_action(f"üõ° –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–æ–∫—Å–∏: {proxy_url}")
    return {
        'url': proxy_url,
        'key': f"{proxy['ip']}:{proxy['port']}"
    }

import asyncio
import time
import json
from asyncio import Lock
from bot.utils.log import log_action

# Cache for direct URLs with TTL
_direct_url_cache = {}
_cache_lock = Lock()
_CACHE_TTL_SECONDS = 2 * 60 * 60  # 2 hours


async def get_direct_url_with_cache(fetch_func, video_url, itags, fallback_itags=None, max_retries=5, delay=5):
    fallback_itags = fallback_itags or []
    key = (video_url, tuple(itags), tuple(fallback_itags))

    async with _cache_lock:
        entry = _direct_url_cache.get(key)
        if entry:
            url, expire_time = entry
            if time.time() < expire_time:
                log_action(f"üì¶ –í–∑—è—Ç–æ –∏–∑ –∫—ç—à–∞: {key}")
                return url
            else:
                _direct_url_cache.pop(key, None)

    # –õ–æ–∫ –Ω–∞ –ø–æ–ø—ã—Ç–∫—É –∑–∞–≥—Ä—É–∑–∫–∏ ‚Äî —á—Ç–æ–±—ã —Ç–æ–ª—å–∫–æ 1 –≤—ã–ø–æ–ª–Ω—è–ª–∞—Å—å
    single_attempt_lock = Lock()
    async with single_attempt_lock:
        for attempt in range(1, max_retries + 1):
            try:
                url = await fetch_func(video_url, itags, fallback_itags)
                async with _cache_lock:
                    _direct_url_cache[key] = (url, time.time() + _CACHE_TTL_SECONDS)
                    log_action(f"üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –∫—ç—à: {key} -> {url}")
                return url
            except Exception as e:
                err_msg = str(e)
                retriable = (
                    "403" in err_msg or
                    "429" in err_msg or
                    "not a bot" in err_msg.lower() or
                    "–Ω–∞–π–¥–µ–Ω—ã –ø–æ–¥—Ö–æ–¥—è—â–∏–µ itag" in err_msg
                )
                if retriable:
                    log_action(f"‚ö†Ô∏è –ü–æ–ø—ã—Ç–∫–∞ {attempt}/{max_retries} ‚Äî –æ—à–∏–±–∫–∞: {err_msg.splitlines()[0]}")
                    if attempt < max_retries:
                        await asyncio.sleep(delay)
                        continue
                raise e